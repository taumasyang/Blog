---
title: 安全原则
author: CS161 Staff
date: 2023-08-09 15:40:00
categories: 计算机安全
license: 'BY-SA'
---

{% note info %}
本系列文章是加州大学伯克利 CS 161《计算机安全》所使用教材的中文翻译。翻译工作大部分由 [DeepL](https://www.deepl.com/) 完成，但译文全部经由本人校对。

原版地址：https://textbook.cs161.org/principles/principles.html
{% endnote %}

# 认清威胁

威胁模型是一个关于攻击者是谁以及他们拥有哪些资源的模型。攻击者会出于金钱、政治、娱乐等各种原因来攻击系统。有些攻击者的行为甚至完全不符合逻辑——他们唯恐天下不乱。

以个人安全为例。比如，犯罪分子可能会为了钱而攻击你，青少年可能会为了取乐而攻击你（或为了赢得一次大冒险），政府可能会为了收集情报而监视你（但你可能还不够重要），亲密伴侣也可能会监视你。

了解攻击者的身份和他们可能拥有的资源后，我们会考虑攻击者的一些常见假设：

1. 攻击者可以在神不知鬼不觉的情况下与你的系统交互，这意味着你不一定能在攻击者攻击你的系统之前发现他们在篡改你的系统。
2. 攻击者掌握了系统的一些基本信息，如操作系统、任何潜在的软件漏洞等。
3. 攻击者具有持久性和幸运性；例如，如果在 1,000,000 次攻击中能够成功一次，攻击者就会尝试 1,000,000 次。
4. 攻击者（在一定程度上）拥有实施攻击所需的资源。这一点将在「安全事关成本」中论述，但根据您的威胁模型，假定攻击者有能力和资源实施攻击。
5. 攻击者可以在不同的系统中协调多个复杂的攻击，这意味着攻击者不必只对一个设备发起攻击，而是可以同时攻击您的整个网络。
6. 每个系统都是潜在目标。例如，曾经有一家赌场因为网络内的鱼缸温度计被黑客入侵。

最后，在处理旧代码时要保持高度警惕，因为最初的假设可能不再有效，威胁模型也可能已经改变。例如，互联网刚诞生时，大多数人都是学者，他们（大多数情况下）相互信任。因此，一些网络协议假定所有其他网络参与者都是可信且没有恶意的。但如今，互联网上有数十亿台设备，其中不乏恶意设备。因此，许多很久以前就设计好的网络协议现在正承受着攻击的压力。

# 考虑人为因素

这里的关键思想是，安全系统必须能为普通人所用，因此在设计时必须考虑到人类将扮演的角色。因此，你必须记住，程序员会犯错误，也会使用允许他们犯错误的工具（如 C 和 C++）。同样，用户喜欢方便，如果一个安全系统无法使用，对用户不友好，那么无论它有多安全，也会被闲置。如果这能给用户的生活带来便利，他们就会想方设法绕过安全系统。

无论你的系统有多安全，一切都取决于人。例如，社会工程学攻击就是利用他人的信任和访问权限来谋取私利。这里的启示是，要考虑向用户提供的工具，并尽量使其傻瓜化和用户友好。

例如，你的电脑弹出通知，告诉你需要重新启动才能完成重要更新的安装；如果你和大多数用户一样，很可能会点击「稍后提醒我」，从而推迟更新。如果电脑正在尝试修复一个安全补丁，更新推迟得越久，电脑受到攻击的时间就越长。然而，由于更新可能会给用户带来不便，他们会为了方便而放弃额外的安全性。

另一个例子：美国国家安全局的加密设备将其密钥材料存储在一个小型物理令牌上。这个令牌的形状就像一把普通的门钥匙。要激活加密设备，只需将钥匙插入设备上的插槽，然后转动钥匙即可。这种界面直观易懂，即使是 18 岁的士兵在战场上也能理解，尽管他们只接受过最起码的密码学培训。

# 安全事关成本

没有一个系统能完全、100% 地抵御所有攻击；相反，系统只需抵御一定程度的攻击。由于实施更多的安全措施通常需要花费更多的资金，因此防御的预期收益应与攻击的预期成本成正比。本质上，在 1 元的物品上安装 100 元的锁是没有意义的。

要理解这一概念，我们可以想想物理保险箱，它们的安全级别是有等级之分的。例如，消费级保险箱 TL-15 可能表示它可以抵御任何人使用普通工具攻击长达 15 分钟，价格可能在 3000 美元左右；而 TL-30 保险箱可以抵御使用普通工具攻击长达 30 分钟，价格可能在 5000 美元左右。最后，TXTL-60（超高端保险箱）可以用普通工具、气割和多达 4 盎司的炸药抵御长达 60 分钟的攻击，价格高达 5 万美元。我们的想法是，安全通常是有代价的。一个更安全的保险箱要比一个不那么安全的保险箱花费更多。如果你有无限的钱，你可以用最好的保险箱锁住所有贵重物品，但由于你没有无限的钱，你必须确定你要保护的东西有多贵重，你必须判断你愿意为保护它付出多少代价。这说明，安全往往是一种成本效益分析，人们需要决定安全值多少钱。

这一原则的推论是，你应该集中精力保护最薄弱的环节。安全就像一个链条：一个系统的安全性取决于最薄弱的环节。攻击者遵循阻力最小的路径，他们会攻击系统最薄弱的环节。在纱门上安装昂贵的高端死锁是毫无意义的；如果攻击者可以直接撕开纱门，然后从纱门进入，他们就不会费力去撬锁了。

与此密切相关的一个原则是保守设计，即在对攻击者有利的假设条件下，应根据最坏的安全故障来评估系统。如果在任何可信的情况下，系统都会变得不安全，那么谨慎的做法就是考虑寻求一个更安全的系统。不过，我们显然必须在安全与成本之间取得平衡，也就是说，我们必须确定我们的威胁模型在多大程度上表明我们确实应该花费资源来应对特定的情况。

# 至少检测攻击

如果说预防是阻止攻击的发生，那么检测就是了解攻击已经发生，而响应则是对攻击采取行动。我们的想法是，如果无法阻止攻击的发生，至少应该能够知道攻击已经发生。一旦知道攻击已经发生，就应该想办法应对，因为没有应对措施的检测是毫无意义的。

例如，联邦信息处理标准（FIPS）是由各政府承包商制定的用于计算机系统的公开标准。第三类设备是该标准中安全级别最高的设备，具有防篡改功能。然而，第三类设备非常昂贵。第二类设备只要求具有防篡改功能，因此，如果有人篡改，就会被发现（例如，封条会被明显破坏）。这意味着它们的制造成本更低，应用范围更广。

在处理响应问题时，应始终假定会发生不好的事情，因此要为最坏的结果做好系统准备。在制定安全计划时，应始终考虑让系统恢复到某种工作状态。例如，对计算机系统进行异地备份就是一个好主意。即使您的系统被完全摧毁，也没有什么大不了的，因为您的所有数据都备份在其他地方。

# 深度防御

深度防御的关键理念是，多种类型的防御应分层进行，这样攻击者就必须攻破所有防御才能成功攻击系统。

以保卫国王的城堡为例。城堡有高高的城墙，城墙后面可能是护城河，然后是另一层城墙。将多个简单的防御策略叠加在一起，可以使安全性更强。然而，深度防御并非万无一失——再多的城墙也无法阻止攻城炮攻击城堡。此外，还要谨防收益递减——如果您已经建造了 100 道城墙，那么第 101 道城墙所增加的保护可能不足以证明建造它的成本是值得的（安全事关成本）。

深度防御的另一个例子是探测器的组合。假设您有两个探测器 $D_1$ 和 $D_2$，它们的误报（False positive）率分别为 $\mathit{FP}_1$ 和 $\mathit{FP}_2$，漏检（False negative）率分别为 $\mathit{FN}_1$ 和 $\mathit{FN}_2$。使用这两个探测器的一种方法是将它们并联起来，即任何一个探测器熄灭都会触发响应，这将提高误报率，降低漏检率。另一方面，我们也可以将两个探测器串联起来，即两个探测器都必须发出警报才能触发响应。在这种情况下，误报率会降低，而漏检率会升高。

# 最小权限

考虑一栋科研大楼，里面有科学家团队以及受雇维护大楼的其他人员（门卫、IT 人员、厨房人员等）。维护人员（如门卫）不得进入这些房间。为了达到最佳安全效果，任何一方都只能拥有发挥其预期作用所需的权限。

用技术术语来说，就是赋予程序完成其工作所需的访问权限——但不能多于此。尽量减少赋予每个程序和系统组件的权限。

最小权限是一种非常强大的方法。它不会降低失败的概率，但可以降低失败的预期代价。程序拥有的权限越少，一旦出错或被绕过，其造成的危害就越小。

例如，最小权限原则有助于减少缓冲区溢出造成的损害。（我们将在下一节详细讨论缓冲区溢出。）如果程序受到缓冲区溢出攻击，那么它很可能会被入侵者完全接管，入侵者将获得程序所拥有的所有权限。因此，程序拥有的权限越少，如果有一天被缓冲区溢出攻击侵入，造成的危害就越小。

就最小权限而言，Unix 是如何做到的？答案是：非常糟糕。每个程序都会获得调用它的用户的所有权限。例如，如果我运行一个编辑器来编辑一个文件，该编辑器就会获得我的用户账户的所有权限，包括读取、修改或删除我所有文件的权限。这远远超出了需要；严格来说，编辑器可能只需要访问被编辑的文件就能完成工作。

就最小权限而言，Windows 如何？答案：一样糟糕。可以说更糟，因为许多用户都在管理员账户下运行，而且许多 Windows 程序都要求你是管理员才能运行。在这种情况下，每个程序都拥有控制整台电脑的全部权力。微软安全团队的人员已经认识到了这种情况所固有的风险，并采取了许多措施来警告人们不要使用管理员权限运行，因此这方面的情况已经有所改善。

# 职责分离

分割权限，不让一个人或一个程序拥有完全的权力。在授予访问权限之前，要求获得不止一方的批准。

例如，在核导弹发射井中，导弹发射前必须得到两名发射官的同意。

要看电影，首先要付钱给收银员，拿到票根。然后，当你进入电影院时，另一名员工会把你的票撕成两半，并把其中的一半收起来，放进一个保险箱里。为什么要给你一张走几步路后就会被收走的票？答案之一是这有助于防止内部欺诈。员工可能会不付钱就让朋友看电影。如果有两名员工在场，就会增加攻击的难度，因为两名员工必须合作才能让别人不付钱就看电影。

总之，如果需要执行特权操作，应要求多方合作行使该特权，因为单方恶意的可能性要大于所有各方恶意串通的可能性。

# 确保万无一失

在执行访问控制策略时，确保检查*每个*对象的*每个*访问权限。这种想法有助于发现漏洞所在。因此，你必须确保所有访问都受到监控和保护。实现这一点的方法之一是通过*引用监控器（reference monitor）*，即所有访问都必须通过的唯一访问点。

# 香农准则

香农的准则（Shannon's Maxim）指出，攻击者知道他们正在攻击的系统。

「隐晦式安全」是指依靠设计、算法或源代码的保密性来确保安全的系统。然而，这种方法的问题在于它非常脆弱，通常很难对有足够动机的攻击者保密系统的设计。从历史上看，「隐晦式安全」的历史记录非常糟糕：许多依靠代码或设计保密来确保安全的系统都惨遭失败。

在为「隐晦式安全」辩护时，人们可能会听到这样的理由：这个系统如此晦涩难懂，全世界只有 100 个人了解它，那么对手费心攻击它的几率又有多大呢？这种推理的一个问题是，这种方法会弄巧成拙。随着系统变得越来越流行，攻击它的动机就会越来越强烈，这时我们就不能依靠系统的隐晦性来阻止攻击者了。

这并不意味着开源应用程序一定比闭源应用程序更安全。但这确实意味着，你不应该相信任何依靠隐晦性来保证安全性的系统，而且你也许应该对那些声称保密源代码会使系统明显更安全的说法持怀疑态度。

因此，你永远不应该把隐晦性作为安全的一部分。始终假定攻击者知道你正在使用的系统的每一个细节（包括算法、硬件、防御等）。

与此密切相关的一个原则是 Kerckhoff 原则，该原则指出，即使攻击者知道系统的所有内部细节，加密系统仍应保持安全。【密钥应该是唯一必须保密的东西，而且系统的设计应该便于更改泄漏（或怀疑泄漏）的密钥。】如果秘密被泄露，更改密钥通常比替换运行软件的每个实例要容易得多。

# 失效安全

选择「失效安全」的默认设置，在系统瘫痪时兼顾安全性和可用性。当我们讨论防火墙时，你会了解到默认拒绝策略，这种策略首先拒绝所有访问，然后只允许明确允许的访问。确保在安全机制失效或崩溃时，它们将默认为安全行为，而不是不安全行为。

例如，防火墙必须明确决定转发某个数据包，否则该数据包就会丢失（丢弃）。如果防火墙发生故障，则不会转发任何数据包。因此，防火墙故障是安全的。这有利于安全。如果防火墙具有故障开放行为，那就危险多了，因为这样一来，攻击者只需等待防火墙崩溃（或诱发崩溃），然后就可以大开杀戒了。

# 从头设计安全

在对现有应用程序进行规范、设计和实施之后，再试图对其进行安全改造通常是非常困难的。在这一点上，无论选择了什么架构，你都会被其束缚住，无法选择以确保最小权限、职责分离、万无一失、深度防御和其他良好特性的方式来分解系统。向后兼容性通常尤其令人痛苦，因为你可能不得不支持所有以前版本软件中最严重的不安全因素。

最后，让我们来看看密码学界广泛接受的三条原则（虽然并不经常被阐明），它们在考虑计算机系统安全性时也能发挥有益的作用。

# 可信计算基（TCB）

现在，您已经了解了构建安全系统的一些重要原则，我们将尝试看看您在设计时可以做些什么来实施这些原则并提高安全性。我们要回答的问题是，如何选择一种架构，以帮助降低系统出现缺陷的可能性，或提高系统在缺陷中幸存的可能性？我们从一个强大的概念开始，即可信计算基（也称为 TCB）的概念。

在任何系统中，可信计算基（TCB）都是系统中必须正确运行才能确保实现系统安全目标的部分。我们必须依靠 TCB 中的每一个组件正常工作。但是，TCB 之外的任何东西都不值得依赖；即使它行为不端或恶意运行，也不能破坏系统的安全目标。一般来说，TCB 要尽可能小，因为更小、更简单的 TCB 更容易编写和审计。

假设安全目标是只允许授权用户使用 SSH 登录我的系统。TCB 是什么？TCB 包括 SSH 守护进程，因为它负责做出身份验证和授权决定；如果它存在漏洞，或者被恶意编程，那么它就会违反我的安全目标，允许未经授权的用户访问。TCB 还包括操作系统，因为操作系统有能力篡改 SSH 守护进程的运行（例如，通过修改其地址空间）。同样，CPU 也在 TCB 中，因为我们依赖 CPU 正确执行 SSH 守护进程的机器指令。假设在同一台机器上安装了网络浏览器应用程序，那么网络浏览器是否在 TCB 中？希望不是！如果我们构建系统的方式是合理的，那么 SSH 守护进程就应该受到保护（通过操作系统的内存保护），不受网络浏览器等无权应用程序的干扰。

## TCB 设计原则

在设计 TCB 时，我们要遵循几条原则：

- *不可绕过（或完整性）*：必须没有办法通过绕过 TCB 来破坏系统安全。
- *防篡改（或安全性）*：TCB 应受到保护，不会被其他人篡改。例如，TCB 以外的系统其他部分不能修改 TCB 的代码或状态。必须保持 TCB 的完整性。
- *可验证（或正确性）*：TCB 的正确性应该可以验证。这通常意味着 TCB 应尽可能简单，因为通常情况下，要验证任何复杂程度的子系统的正确性，都超出了技术水平。

保持 TCB 的**小并且简单**是非常好的。需要编写的代码越少，犯错误或引入某种实现缺陷的机会就越少。行业标准错误率为每千行代码 1-5 个缺陷。因此，包含 1,000 行代码的 TCB 可能会有 1-5 个缺陷，而包含 100,000 行代码的 TCB 可能会有 100-500 个缺陷。如果我们需要努力确保找到并消除对手可以利用的任何缺陷，那么选择哪一个就非常明显了！[^1] 这告诉我们要减少代码：设计系统时，尽可能多地将代码移到 TCB 之外。

[^1]: Windows XP 包含约 4000 万行代码——所有这些代码都在 TCB 中。天哪！

## TCB 的好处

TCB 的概念是一个非常强大和实用的概念，因为它允许一种原始但有效的模块化形式。它让我们把系统分成两部分：对安全至关重要的部分（TCB）和其他部分。

这种分离对安全性来说是一个重大胜利。安全很难。要构建既安全又正确的系统确实很难。系统包含的部分越多，就越难保证其安全性。如果我们能够确定一个清晰的 TCB，那么我们就会知道，只有 TCB 中的部分是正确的，系统才是安全的。因此，在考虑安全性问题时，我们可以把精力集中在真正重要的地方。而且，如果 TCB 只占系统的一小部分，我们就更有可能最终获得一个安全的系统：我们需要依赖的系统越少，系统令人失望的可能性就越小。

总之，一些好的原则是：

- 了解 TCB 中的内容。在设计系统时，要清楚地识别 TCB。
- 尽量使 TCB 具有不可绕过性、防篡改性和可验证性。
- 保持简单、愚蠢 (Keep It Simple, Stupid, KISS)。TCB 越简单，你就越有可能把它做对。
- 分解确保安全。选择系统分解/模块化时，不能只考虑功能或性能——要选择一种能让 TCB 尽可能简单明了的架构。

# TOCTTOU 漏洞

确保万无一失的常见故障涉及竞速条件。检查时间到使用时间（time of check to time of use, TOCTTOU）漏洞通常出现在执行访问控制策略时，如使用引用监视器时。请看下面的代码：

```
procedure withdraw(amount w) {
    // contact central server to get balance
    1. let b := balance
    2. if b < w, abort

    // contact central server to set the balance
    3. set balance := b - w
    4. give w dollars to the user
}
```

该代码输入您要提取的金额 `w`。然后，它会在数据库中查询您的银行余额；如果您的账户中没有足够的钱来提取指定的金额，那么它就会中止交易。如果您有足够的钱，它就会将您的余额减去您要提取的金额，然后将现金发放给您。

假设多个取款呼叫可以同时进行（即两台独立的自动取款机），还假设攻击者能以某种方式暂停一台自动取款机上程序的执行。

因此，假设您当前的账户余额为 100 美元，您想取出 100 美元。在第一台自动取款机上，假设您在步骤 2 之后暂停。然后，您到第二台 ATM 成功取款 100 美元（这意味着您的账户余额现在应该是 0 美元）。然后，你回到第一台自动取款机，取消暂停程序；由于账户余额检查是在你从第二台自动取款机取款之前完成的，因此第一台自动取款机仍然认为你的账户里有 100 美元，并允许你再取 100 美元！因此，尽管您的银行账户一开始只有 100 美元，但最后却有了 200 美元。

这就是所谓的「检查时间到使用时间」（TOCTTOU）漏洞，因为在检查和使用被检查的状态之间，状态发生了某种改变。在上述示例中，在检查余额和设置余额之间，余额以某种方式发生了变化。
